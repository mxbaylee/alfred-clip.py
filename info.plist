<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>bundleid</key>
	<string></string>
	<key>connections</key>
	<dict>
		<key>B6FE8212-7A0A-4A71-A922-0FE50BD12268</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>D4F0197D-C1DD-4038-8B31-AF540F784683</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>BB41D459-AE65-4994-A143-46C202E348C0</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>14258FF9-2C70-4903-BC3E-C8FAA1CE1A7D</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>D4F0197D-C1DD-4038-8B31-AF540F784683</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>EB6D5422-62A8-413C-917C-ABD99CBC6D62</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>EB6D5422-62A8-413C-917C-ABD99CBC6D62</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>59A0180B-0FAD-4510-99A7-EF3D593B68EE</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>sourceoutputuid</key>
				<string>994FAF9B-05D4-4470-8CDA-4024568946F3</string>
				<key>vitoclose</key>
				<false/>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>59A0180B-0FAD-4510-99A7-EF3D593B68EE</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>14258FF9-2C70-4903-BC3E-C8FAA1CE1A7D</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
	</dict>
	<key>createdby</key>
	<string>Mx Baylee</string>
	<key>description</key>
	<string>A 📋 Clipboard utility for 🎩 Alfred App, that can utilize 🐍 Python.</string>
	<key>disabled</key>
	<false/>
	<key>name</key>
	<string>clip.py</string>
	<key>objects</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<false/>
				<key>escaping</key>
				<integer>68</integer>
				<key>script</key>
				<string>"""
🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍
Do not edit this file
🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍
"""
from unittest.mock import MagicMock
import plistlib
import os
import re
import copy

os.environ['CI'] = 'true'
os.environ['LOG_LEVEL'] = 'DEBUG'

# Import the relevant Script Filters stored in 🎩 Alfred
with open('info.plist', 'rb') as f:
    plist_dict = plistlib.load(f)
for item in plist_dict['objects']:
    if 'config' in item and 'script' in item['config']:
        if item['uid'] == "BB41D459-AE65-4994-A143-46C202E348C0":
            sys.stdout = sys.stderr
            exec(item['config']['script'])
            sys.stdout = sys.__stdout__

def eq(condition: Any, expected: Any) -&gt; None:
    try:
        assert condition == expected
    except AssertionError as e:
        print(f"AssertionError: Expected {expected}, but got {condition}.")
        raise e

try:
    # String helper
    assert 'helloremipsum' == StringHelper.append_unique("hello", "loremipsum")
    assert 'worldabc' == StringHelper.append_unique("world", "ldabc")
    assert 'foobar' == StringHelper.append_unique("foo", "bar")

    # MagicEval
    magic_clippy = MagicMock(spec=Clippy)
    magic_clippy.get_min.return_value = 0
    magic_clippy.all.return_value = []

    # MagicEval.populate_global single variable
    magic_clippy.all.return_value = [
        { 'rowid': 1, 'item': '1hello' },
    ]
    meval = MagicEval(clippy=magic_clippy)
    meval.populate_global()
    eq(t1, '1hello')
    eq(f1, 1)

    # MagicEval.populate_global hex key
    magic_clippy.all.return_value = [
        { 'rowid': 200, 'item': '2hello' }, # 200 == c8
    ]
    meval = MagicEval(clippy=magic_clippy)
    meval.populate_global()
    eq(tc8, '2hello')
    eq(fc8, 2)

    # MagicEval.evaluate
    magic_clippy.all.return_value = [
        { 'rowid': 200, 'item': '2285' }, # 200 == c8
        { 'rowid': 201, 'item': '628' }, # 201 == c9
    ]
    meval = MagicEval(clippy=magic_clippy)
    # String
    eq(len(meval.evaluate('tc8+tc9')), 1)
    eq(meval.evaluate('tc8+tc9')[0]['arg'], '2285628')
    # Float
    eq(len(meval.evaluate('fc8*fc9')), 1)
    eq(meval.evaluate('fc8*fc9')[0]['arg'], '1434980.0')

    # Complete!
    print('💚 Passed!')
except Exception as e:
    print('🔴 Failure!')
    print(f"Error: {str(e)}")


"""
import unittest

class TestMyFunction(unittest.TestCase):
    def setUp(self):
        # Set up code that is executed before each test method
        self.mock_object = MagicMock()
        self.test_data = [1, 2, 3]

    def test_my_function1(self):
        # Test method 1 that uses the set up code
        self.assertEqual(len(self.test_data), 3)

    def test_my_function2(self):
        # Test method 2 that uses the set up code
        self.assertIsInstance(self.mock_object, MagicMock)
"""</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>9</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>D4F0197D-C1DD-4038-8B31-AF540F784683</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>lastpathcomponent</key>
				<false/>
				<key>onlyshowifquerypopulated</key>
				<false/>
				<key>removeextension</key>
				<false/>
				<key>text</key>
				<string></string>
				<key>title</key>
				<string></string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.notification</string>
			<key>uid</key>
			<string>59A0180B-0FAD-4510-99A7-EF3D593B68EE</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>alfredfiltersresults</key>
				<false/>
				<key>alfredfiltersresultsmatchmode</key>
				<integer>0</integer>
				<key>argumenttreatemptyqueryasnil</key>
				<true/>
				<key>argumenttrimmode</key>
				<integer>0</integer>
				<key>argumenttype</key>
				<integer>0</integer>
				<key>escaping</key>
				<integer>68</integer>
				<key>keyword</key>
				<string>clippy&gt;</string>
				<key>queuedelaycustom</key>
				<integer>3</integer>
				<key>queuedelayimmediatelyinitially</key>
				<true/>
				<key>queuedelaymode</key>
				<integer>0</integer>
				<key>queuemode</key>
				<integer>1</integer>
				<key>runningsubtext</key>
				<string></string>
				<key>script</key>
				<string>"""
🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍
Do not edit this file
🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍
"""
import sys
import os
import json

## A place for the dot "." commands

input_string = (os.environ.get("QUERY") or "{query}").strip()

if input_string.startswith("."):
    print(json.dumps({
        "items": [
            item for item in [
              {
                  "title": "📐",
                  "subtitle": "Run Unit Tests",
                  "key": ".test",
                  "arg": 'test',
              }
            ] if item['key'].startswith(input_string)
        ]
    }))
</string>
				<key>scriptargtype</key>
				<integer>0</integer>
				<key>scriptfile</key>
				<string></string>
				<key>subtext</key>
				<string></string>
				<key>title</key>
				<string></string>
				<key>type</key>
				<integer>9</integer>
				<key>withspace</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>B6FE8212-7A0A-4A71-A922-0FE50BD12268</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>conditions</key>
				<array>
					<dict>
						<key>inputstring</key>
						<string></string>
						<key>matchcasesensitive</key>
						<false/>
						<key>matchmode</key>
						<integer>4</integer>
						<key>matchstring</key>
						<string>pass</string>
						<key>outputlabel</key>
						<string>💚 Pass!</string>
						<key>uid</key>
						<string>994FAF9B-05D4-4470-8CDA-4024568946F3</string>
					</dict>
				</array>
				<key>elselabel</key>
				<string>🔴 Fail!</string>
				<key>hideelse</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.conditional</string>
			<key>uid</key>
			<string>EB6D5422-62A8-413C-917C-ABD99CBC6D62</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>autopaste</key>
				<false/>
				<key>clipboardtext</key>
				<string>{query}</string>
				<key>ignoredynamicplaceholders</key>
				<false/>
				<key>transient</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.clipboard</string>
			<key>uid</key>
			<string>14258FF9-2C70-4903-BC3E-C8FAA1CE1A7D</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>alfredfiltersresults</key>
				<false/>
				<key>alfredfiltersresultsmatchmode</key>
				<integer>0</integer>
				<key>argumenttreatemptyqueryasnil</key>
				<true/>
				<key>argumenttrimmode</key>
				<integer>0</integer>
				<key>argumenttype</key>
				<integer>1</integer>
				<key>escaping</key>
				<integer>68</integer>
				<key>keyword</key>
				<string>clippy&gt;</string>
				<key>queuedelaycustom</key>
				<integer>3</integer>
				<key>queuedelayimmediatelyinitially</key>
				<true/>
				<key>queuedelaymode</key>
				<integer>0</integer>
				<key>queuemode</key>
				<integer>2</integer>
				<key>runningsubtext</key>
				<string></string>
				<key>script</key>
				<string>"""
🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍
Do not edit this file
🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍
"""
from typing import List, Dict, Any
from datetime import datetime, timedelta
import os
import sqlite3
import json
import re
import logging
import sys
import plistlib


# Setup
TIMESTAMP = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
FILE_NAME = ".min_value.tmp" # matches other file
LOG_LEVEL = (os.environ.get("LOG_LEVEL") or "").strip().upper()
try:
    level = getattr(logging, LOG_LEVEL)
except AttributeError:
    level = logging.INFO
logging.basicConfig(stream=sys.stderr, level=level)


# Import the relevant user functions/imports stored in 🎩 Alfred
with open('info.plist', 'rb') as f:
    plist_dict = plistlib.load(f)
for item in plist_dict['objects']:
    if 'config' in item and 'script' in item['config']:
        if item['uid'] == "13C80445-BF4B-49E0-8AE9-3EFB5AFDEDE2":
            sys.stdout = sys.stderr
            exec(item['config']['script'])
            sys.stdout = sys.__stdout__

# Classes
class StringHelper:
    @staticmethod
    def append_unique(s1: str, s2: str) -&gt; str:
        """
            &gt;&gt;&gt; StringHelper.append_unique("hello", "loremipsum")
            'helloremipsum'
            &gt;&gt;&gt; StringHelper.append_unique("world", "ldabc")
            'worldabc'
            &gt;&gt;&gt; StringHelper.append_unique("foo", "bar")
            'foobar'
        """
        overlap = 0
        for i in range(1, min(len(s1), len(s2))+1):
            if s1[-i:] == s2[:i]:
                overlap = i
        return s1 + s2[overlap:]


class Clippy:
    def __init__(self, clippy_path: str):
        self.conn = False
        self.clippy_path = clippy_path
        self._min = None
        self.conn = sqlite3.connect(clippy_path)

    def __del__(self):
        if self and self.conn:
            self.conn.close()

    def all(self) -&gt; List[Dict]:
        cursor = self.conn.cursor()
        cursor.execute("""
SELECT rowid, item
FROM clipboard
WHERE dataType = 0
        """)
        rows = cursor.fetchall()
        columns = [column[0] for column in cursor.description]
        return [dict(zip(columns, row)) for row in rows]

    def _upsert_min(self, new_min: float) -&gt; float:
        now = datetime.now()
        if os.path.isfile(FILE_NAME):
            # Get previously set last updated at
            filetime = datetime.fromtimestamp(os.path.getmtime(FILE_NAME))

            # If less than 1 hour use that value
            if now - filetime &lt; timedelta(hours=1):
                # touch the file to renew the value timeout
                os.utime(FILE_NAME, (now.timestamp(), now.timestamp()))
                logging.debug(f'{TIMESTAMP}: touching `{FILE_NAME}`')

                # read the value
                with open(FILE_NAME, 'r') as f:
                    try:
                        return float(f.read())
                    except Exception as e:
                        pass

        logging.debug(f'{TIMESTAMP}: writing new min `{new_min}` to file `{FILE_NAME}`')
        with open(FILE_NAME, 'w') as f:
            f.write(str(new_min))
        return new_min

    def get_min(self) -&gt; int:
        if self._min is None:
            cursor = self.conn.cursor()
            cursor.execute("""
SELECT min(rowid)
FROM clipboard
WHERE dataType = 0
ORDER BY ts DESC, rowid DESC
LIMIT 1;
        """)
            result = cursor.fetchone()
            if result is not None:
                self._min = self._upsert_min(result[0])
        return self._min or 0

    def get_recent(self) -&gt; List[Dict]:
        cursor = self.conn.cursor()
        cursor.execute("""
SELECT rowid, item, apppath
FROM clipboard
WHERE dataType = 0
ORDER BY ts DESC, rowid DESC
LIMIT 35
        """)
        rows = cursor.fetchall()
        columns = [column[0] for column in cursor.description]
        return [dict(zip(columns, row)) for row in rows]


class Presenter:
    def __init__(self, clippy: Clippy, input_string: str = ""):
        self.clippy = clippy
        self.items = [] if input_string.endswith(";") else clippy.get_recent()
        self.input_string = input_string

    def __setattr__(self, name: str, value: Any) -&gt; None:
        if name == 'items':
            if not isinstance(value, list):
                raise ValueError('items must be a list')
            super().__setattr__(name, value)
        else:
            super().__setattr__(name, value)

    def add(self, item: Dict) -&gt; None:
        self.items.append(item)

    def decorated_items(self) -&gt; List[Dict]:
        decorated_list = []
        typed_var = re.search(r'[ft][0-9A-Fa-f]{2,}$', self.input_string)
        for item in self.items:
            [item1, item2] = self.decorate_item(item)
            if typed_var is None or item1['title'].startswith(typed_var.group(0)):
                decorated_list.append(item1)
            if typed_var is None or item2['title'].startswith(typed_var.group(0)):
                decorated_list.append(item2)
        return decorated_list

    def decorate_item(self, item: Dict) -&gt; List[Dict]:
        try:
            fvalue = float(re.sub(r'[^\d.]+', '', item['item']))
        except Exception as e:
            fvalue = 0.0
        lmin = self.clippy.get_min()
        rowid = hex(int(item['rowid']-lmin))[2:]
        return [
            {
                "title": f"f{rowid}",
                "subtitle": fvalue,
                "valid": False,
                "autocomplete": StringHelper.append_unique(self.input_string, f"f{rowid}"),
                "icon": {
                    "type": "fileicon",
                    "path": item['apppath'],
                }
            },
            {
                "title": f"t{rowid}",
                "subtitle": item['item'].replace("\n", "¶"),
                "valid": False,
                "autocomplete": StringHelper.append_unique(self.input_string, f"t{rowid}"),
                "icon": {
                    "type": "fileicon",
                    "path": item['apppath'],
                }
            },
        ]

    def to_a(self) -&gt; List[Dict]:
        return self.decorated_items()


class MagicEval:
    def __init__(self, clippy: Clippy):
        self.clippy = clippy

    def _eval(self, input_string: str) -&gt; Any:
        try:
            result = eval(input_string)
            logging.debug(f'{TIMESTAMP}: Input: {input_string}, Output: {result}')
            return result
        except Exception as e:
            logging.exception(f"{TIMESTAMP}: Error / Input: {input_string} =&gt; Exception: {str(e)}\n")
            raise e

    def evaluate(self, input_string: str) -&gt; List[Dict]:
        if len(input_string) == 0:
            return [
                {
                    "title": "🐍",
                    "subtitle": "🌻 Keep typing...",
                }
            ]
        try:
            # strip the ending ;
            if input_string[-1] == ";":
                input_string = input_string[:-1]
            # globals
            self.populate_global()
            # eval
            result = str(self._eval(input_string))
            # results
            return [
                {
                    "title": result.replace("\n", "¶"),
                    "arg": result,
                }
            ]
        except Exception as e:
            return [
                {
                    "uid": "cliprepl",
                    "title": "🚧 " + input_string,
                    "subtitle": e.args[0],
                }
            ]

    def populate_global(self):
        # Defaults to de-clutter the logs
        globals()['f'] = 0.0
        globals()['t'] = ""

        # Create a cursor object
        items = self.clippy.all()
        lmin = self.clippy.get_min()
        for row in items:
            rowid = hex(int(row['rowid']-lmin))[2:]
            try:
                item = float(re.sub(r'[^\d.]+', '', row['item']))
                globals()['f' + rowid] = item
            except Exception as e:
                globals()['f' + rowid] = 0.0
            try:
                item = str(row['item'])
                globals()['t' + rowid] = item
            except Exception as e:
                globals()['t' + rowid] = ""

# Main
is_ci = str(os.environ.get("CI", "false")).lower() == 'true'
input_string = (os.environ.get("QUERY") or "{query}").strip()
if not is_ci and not input_string.startswith('.'):
    # Setup
    clippy = Clippy(os.path.abspath(os.environ.get('DB_PATH', '')))
    meval = MagicEval(clippy=clippy)
    presenter = Presenter(clippy, input_string)
    # Items
    type_ahead_items = presenter.to_a()
    eval_items = meval.evaluate(input_string)
    # Response
    print(json.dumps({
        "items": eval_items + type_ahead_items
    }))
</string>
				<key>scriptargtype</key>
				<integer>0</integer>
				<key>scriptfile</key>
				<string></string>
				<key>subtext</key>
				<string></string>
				<key>title</key>
				<string>🐍</string>
				<key>type</key>
				<integer>9</integer>
				<key>withspace</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>BB41D459-AE65-4994-A143-46C202E348C0</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<false/>
				<key>escaping</key>
				<integer>68</integer>
				<key>script</key>
				<string>"""
🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍

Edit me!

This is a place to put your custom functions and imports.

When we include this file, we rewrite stdout to stderror since stdout can interfere with Alfred results.

🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍🐍

"""


import numpy as np

print(np.array([1,2,3]))</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>9</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>13C80445-BF4B-49E0-8AE9-3EFB5AFDEDE2</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
	</array>
	<key>readme</key>
	<string>![Icon](./icon.png)

## 🐍 clip.py

A REPL with Alfred's clipboard history being easily accessible in scripts.

Technically this is a `REP`, since the `L` in REPL is for loop. The output is put into your clipboard, so it's value is preserved, but only as another clipboard item. Any state you create in a previous evaluation is not remembered.

### 📶 Setup

By default the `User Configuration` should be setup correctly if you are using Alfred 5.

	* `💽 Database Path` - The PATH to the `clipboard.alfdb` file.
	* `🗃️ Log Level`  - The level of debugging you want. Defaults to `info`.

## ⌨️ Usage

Try: `clippy&gt;1+1`

Open the prompt by typing `cliprepl&gt;` and you'll be presented with a list of previous clipboard items. Try using this as a standard Python REPL such as `cliprepl&gt;1+1` will give you `2`

### 📋 Clipboard

Try: `clippy&gt;t1+t1`

Most of the results you are seeing are the clipboard contents.

To read the results you'll notice that
	* `title` is a unique identifier, which equates to a hex'd of rowid
		* By hex, I mean that a rowid of `231` would turn into `e7`
	* `subtitle` is the value of the item (try hitting `cmd` for the float)

To access the variables in your command, you'll need to give it a type prefix.

#### Prefixes

	* `t` prefix: (eg `te7`) would be the the value casted as a string.
		* For example `cliprepl&gt; te7+te7` would append the text to itself.
	* `f` prefix: (eg `fe7`) is the variable casted as a float.
		* For example `cliprepl&gt; fe7+fe7` would add the two floats together.

#### Advanced

	* Hitting `&lt;enter&gt;` or `&lt;tab&gt;` would autocomplete into 🎩 Alfred.
	* Hitting `&lt;cmd&gt;` will show you the value casted as a float.
	* Ending your query with a semicolon (`;`) will hide the clipboard results.
	* Add custom functions and imports to the 🧡 Orange "Run Script"

## 🔌 Developers, Developers, Developers

### 🪵 Logs

Logs are routed to stderr, this makes them visible in the debugger.

### 📐 Tests

There are a handful of unit tests that are runnable as well:

	* `clippy&gt;.test`

### 💽 Schema

For reference, here is the schema of the `clipboard.alfdb` file as it's currently known.

* `rowid` : A unique identifier generated by sqlite.
* `item` : Likely the value.
* `ts` : The timestamp, in seconds, when it was captured. Non unique.
* `app` : A short name for the application it was copied from.
* `apppath` : The absolute path of the application it was copied from.
* `dataType` : Enum of `0` meaning text, or `1` meaning an image.
* `dataHash` : If `dataType` is `1` this is a reference to the file on disk.

We do not simply sort by `rowid` but often by `ts` as well (`ts DESC, rowid DESC`) because it's possible for Alfred to update the `ts` in cases where you copy it back to your clipboard.</string>
	<key>uidata</key>
	<dict>
		<key>13C80445-BF4B-49E0-8AE9-3EFB5AFDEDE2</key>
		<dict>
			<key>colorindex</key>
			<integer>2</integer>
			<key>note</key>
			<string>🌈 Custom Scripts</string>
			<key>xpos</key>
			<real>165</real>
			<key>ypos</key>
			<real>335</real>
		</dict>
		<key>14258FF9-2C70-4903-BC3E-C8FAA1CE1A7D</key>
		<dict>
			<key>colorindex</key>
			<integer>4</integer>
			<key>xpos</key>
			<real>540</real>
			<key>ypos</key>
			<real>210</real>
		</dict>
		<key>59A0180B-0FAD-4510-99A7-EF3D593B68EE</key>
		<dict>
			<key>colorindex</key>
			<integer>11</integer>
			<key>xpos</key>
			<real>540</real>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>B6FE8212-7A0A-4A71-A922-0FE50BD12268</key>
		<dict>
			<key>colorindex</key>
			<integer>6</integer>
			<key>note</key>
			<string>📐 For testing, should be removed in production.</string>
			<key>xpos</key>
			<real>45</real>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>BB41D459-AE65-4994-A143-46C202E348C0</key>
		<dict>
			<key>colorindex</key>
			<integer>5</integer>
			<key>xpos</key>
			<real>45</real>
			<key>ypos</key>
			<real>215</real>
		</dict>
		<key>D4F0197D-C1DD-4038-8B31-AF540F784683</key>
		<dict>
			<key>colorindex</key>
			<integer>6</integer>
			<key>xpos</key>
			<real>225</real>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>EB6D5422-62A8-413C-917C-ABD99CBC6D62</key>
		<dict>
			<key>colorindex</key>
			<integer>10</integer>
			<key>xpos</key>
			<real>395</real>
			<key>ypos</key>
			<real>70</real>
		</dict>
	</dict>
	<key>userconfigurationconfig</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>~/Library/Application Support/Alfred/Databases/clipboard.alfdb</string>
				<key>filtermode</key>
				<integer>2</integer>
				<key>placeholder</key>
				<string></string>
				<key>required</key>
				<true/>
			</dict>
			<key>description</key>
			<string>The path to the `clipboard.alfdb` file.</string>
			<key>label</key>
			<string>💽 Database Path</string>
			<key>type</key>
			<string>filepicker</string>
			<key>variable</key>
			<string>DB_PATH</string>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>INFO</string>
				<key>pairs</key>
				<array>
					<array>
						<string>DEBUG</string>
						<string>DEBUG</string>
					</array>
					<array>
						<string>INFO</string>
						<string>INFO</string>
					</array>
					<array>
						<string>WARNING</string>
						<string>WARNING</string>
					</array>
					<array>
						<string>ERROR</string>
						<string>ERROR</string>
					</array>
					<array>
						<string>CRITICAL</string>
						<string>CRITICAL</string>
					</array>
				</array>
			</dict>
			<key>description</key>
			<string>See 🐍 Python's Documentation
https://docs.python.org/3/library/logging.html#logging-levels</string>
			<key>label</key>
			<string>🗃️ Log Level</string>
			<key>type</key>
			<string>popupbutton</string>
			<key>variable</key>
			<string>LOG_LEVEL</string>
		</dict>
	</array>
	<key>variablesdontexport</key>
	<array/>
	<key>version</key>
	<string>0.0.1</string>
	<key>webaddress</key>
	<string>https://github.com/mxbaylee</string>
</dict>
</plist>
