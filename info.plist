<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>bundleid</key>
	<string></string>
	<key>connections</key>
	<dict>
		<key>B6FE8212-7A0A-4A71-A922-0FE50BD12268</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>D4F0197D-C1DD-4038-8B31-AF540F784683</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>BB41D459-AE65-4994-A143-46C202E348C0</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>14258FF9-2C70-4903-BC3E-C8FAA1CE1A7D</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>D4F0197D-C1DD-4038-8B31-AF540F784683</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>EB6D5422-62A8-413C-917C-ABD99CBC6D62</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
		<key>EB6D5422-62A8-413C-917C-ABD99CBC6D62</key>
		<array>
			<dict>
				<key>destinationuid</key>
				<string>59A0180B-0FAD-4510-99A7-EF3D593B68EE</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>sourceoutputuid</key>
				<string>994FAF9B-05D4-4470-8CDA-4024568946F3</string>
				<key>vitoclose</key>
				<false/>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>59A0180B-0FAD-4510-99A7-EF3D593B68EE</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
			<dict>
				<key>destinationuid</key>
				<string>14258FF9-2C70-4903-BC3E-C8FAA1CE1A7D</string>
				<key>modifiers</key>
				<integer>0</integer>
				<key>modifiersubtext</key>
				<string></string>
				<key>vitoclose</key>
				<false/>
			</dict>
		</array>
	</dict>
	<key>createdby</key>
	<string>Mx Baylee</string>
	<key>description</key>
	<string>A ğŸ“‹ Clipboard utility for ğŸ© Alfred App, that can utilize ğŸ Python.</string>
	<key>disabled</key>
	<false/>
	<key>name</key>
	<string>clip.py</string>
	<key>objects</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<false/>
				<key>escaping</key>
				<integer>68</integer>
				<key>script</key>
				<string>"""
ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
Do not edit this file
ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
"""
from unittest.mock import MagicMock
import plistlib
import os
import re
import copy

os.environ['CI'] = 'true'
os.environ['LOG_LEVEL'] = 'DEBUG'

# Import the relevant Script Filters stored in ğŸ© Alfred
with open('info.plist', 'rb') as f:
    plist_dict = plistlib.load(f)
for item in plist_dict['objects']:
    if 'config' in item and 'script' in item['config']:
        if item['uid'] == "BB41D459-AE65-4994-A143-46C202E348C0":
            sys.stdout = sys.stderr
            exec(item['config']['script'])
            sys.stdout = sys.__stdout__

def eq(condition: Any, expected: Any) -&gt; None:
    try:
        assert condition == expected
    except AssertionError as e:
        print(f"AssertionError: Expected {expected}, but got {condition}.")
        raise e

try:
    # String helper
    assert 'helloremipsum' == StringHelper.append_unique("hello", "loremipsum")
    assert 'worldabc' == StringHelper.append_unique("world", "ldabc")
    assert 'foobar' == StringHelper.append_unique("foo", "bar")

    # MagicEval
    magic_clippy = MagicMock(spec=Clippy)
    magic_clippy.get_min.return_value = 0
    magic_clippy.all.return_value = []

    # MagicEval.populate_global single variable
    magic_clippy.all.return_value = [
        { 'rowid': 1, 'item': '1hello' },
    ]
    meval = MagicEval(clippy=magic_clippy)
    meval.populate_global()
    eq(t1, '1hello')
    eq(f1, 1)

    # MagicEval.populate_global hex key
    magic_clippy.all.return_value = [
        { 'rowid': 200, 'item': '2hello' }, # 200 == c8
    ]
    meval = MagicEval(clippy=magic_clippy)
    meval.populate_global()
    eq(tc8, '2hello')
    eq(fc8, 2)

    # MagicEval.evaluate
    magic_clippy.all.return_value = [
        { 'rowid': 200, 'item': '2285' }, # 200 == c8
        { 'rowid': 201, 'item': '628' }, # 201 == c9
    ]
    meval = MagicEval(clippy=magic_clippy)
    # String
    eq(len(meval.evaluate('tc8+tc9')), 1)
    eq(meval.evaluate('tc8+tc9')[0]['arg'], '2285628')
    # Float
    eq(len(meval.evaluate('fc8*fc9')), 1)
    eq(meval.evaluate('fc8*fc9')[0]['arg'], '1434980.0')

    # Complete!
    print('ğŸ’š Passed!')
except Exception as e:
    print('ğŸ”´ Failure!')
    print(f"Error: {str(e)}")


"""
import unittest

class TestMyFunction(unittest.TestCase):
    def setUp(self):
        # Set up code that is executed before each test method
        self.mock_object = MagicMock()
        self.test_data = [1, 2, 3]

    def test_my_function1(self):
        # Test method 1 that uses the set up code
        self.assertEqual(len(self.test_data), 3)

    def test_my_function2(self):
        # Test method 2 that uses the set up code
        self.assertIsInstance(self.mock_object, MagicMock)
"""</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>9</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>D4F0197D-C1DD-4038-8B31-AF540F784683</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>lastpathcomponent</key>
				<false/>
				<key>onlyshowifquerypopulated</key>
				<false/>
				<key>removeextension</key>
				<false/>
				<key>text</key>
				<string></string>
				<key>title</key>
				<string></string>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.notification</string>
			<key>uid</key>
			<string>59A0180B-0FAD-4510-99A7-EF3D593B68EE</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>alfredfiltersresults</key>
				<false/>
				<key>alfredfiltersresultsmatchmode</key>
				<integer>0</integer>
				<key>argumenttreatemptyqueryasnil</key>
				<true/>
				<key>argumenttrimmode</key>
				<integer>0</integer>
				<key>argumenttype</key>
				<integer>0</integer>
				<key>escaping</key>
				<integer>68</integer>
				<key>keyword</key>
				<string>clippy&gt;</string>
				<key>queuedelaycustom</key>
				<integer>3</integer>
				<key>queuedelayimmediatelyinitially</key>
				<true/>
				<key>queuedelaymode</key>
				<integer>0</integer>
				<key>queuemode</key>
				<integer>1</integer>
				<key>runningsubtext</key>
				<string></string>
				<key>script</key>
				<string>"""
ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
Do not edit this file
ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
"""
import sys
import os
import json

## A place for the dot "." commands

input_string = (os.environ.get("QUERY") or "{query}").strip()

if input_string.startswith("."):
    print(json.dumps({
        "items": [
            item for item in [
              {
                  "title": "ğŸ“",
                  "subtitle": "Run Unit Tests",
                  "key": ".test",
                  "arg": 'test',
              }
            ] if item['key'].startswith(input_string)
        ]
    }))
</string>
				<key>scriptargtype</key>
				<integer>0</integer>
				<key>scriptfile</key>
				<string></string>
				<key>subtext</key>
				<string></string>
				<key>title</key>
				<string></string>
				<key>type</key>
				<integer>9</integer>
				<key>withspace</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>B6FE8212-7A0A-4A71-A922-0FE50BD12268</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>conditions</key>
				<array>
					<dict>
						<key>inputstring</key>
						<string></string>
						<key>matchcasesensitive</key>
						<false/>
						<key>matchmode</key>
						<integer>4</integer>
						<key>matchstring</key>
						<string>pass</string>
						<key>outputlabel</key>
						<string>ğŸ’š Pass!</string>
						<key>uid</key>
						<string>994FAF9B-05D4-4470-8CDA-4024568946F3</string>
					</dict>
				</array>
				<key>elselabel</key>
				<string>ğŸ”´ Fail!</string>
				<key>hideelse</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.utility.conditional</string>
			<key>uid</key>
			<string>EB6D5422-62A8-413C-917C-ABD99CBC6D62</string>
			<key>version</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>autopaste</key>
				<false/>
				<key>clipboardtext</key>
				<string>{query}</string>
				<key>ignoredynamicplaceholders</key>
				<false/>
				<key>transient</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.output.clipboard</string>
			<key>uid</key>
			<string>14258FF9-2C70-4903-BC3E-C8FAA1CE1A7D</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>alfredfiltersresults</key>
				<false/>
				<key>alfredfiltersresultsmatchmode</key>
				<integer>0</integer>
				<key>argumenttreatemptyqueryasnil</key>
				<true/>
				<key>argumenttrimmode</key>
				<integer>0</integer>
				<key>argumenttype</key>
				<integer>1</integer>
				<key>escaping</key>
				<integer>68</integer>
				<key>keyword</key>
				<string>clippy&gt;</string>
				<key>queuedelaycustom</key>
				<integer>3</integer>
				<key>queuedelayimmediatelyinitially</key>
				<true/>
				<key>queuedelaymode</key>
				<integer>0</integer>
				<key>queuemode</key>
				<integer>2</integer>
				<key>runningsubtext</key>
				<string></string>
				<key>script</key>
				<string>"""
ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
Do not edit this file
ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ
"""
from typing import List, Dict, Any
from datetime import datetime, timedelta
import os
import sqlite3
import json
import re
import logging
import sys
import plistlib


# Setup
TIMESTAMP = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
FILE_NAME = ".min_value.tmp" # matches other file
LOG_LEVEL = (os.environ.get("LOG_LEVEL") or "").strip().upper()
try:
    level = getattr(logging, LOG_LEVEL)
except AttributeError:
    level = logging.INFO
logging.basicConfig(stream=sys.stderr, level=level)


# Import the relevant user functions/imports stored in ğŸ© Alfred
with open('info.plist', 'rb') as f:
    plist_dict = plistlib.load(f)
for item in plist_dict['objects']:
    if 'config' in item and 'script' in item['config']:
        if item['uid'] == "13C80445-BF4B-49E0-8AE9-3EFB5AFDEDE2":
            sys.stdout = sys.stderr
            exec(item['config']['script'])
            sys.stdout = sys.__stdout__

# Classes
class StringHelper:
    @staticmethod
    def append_unique(s1: str, s2: str) -&gt; str:
        """
            &gt;&gt;&gt; StringHelper.append_unique("hello", "loremipsum")
            'helloremipsum'
            &gt;&gt;&gt; StringHelper.append_unique("world", "ldabc")
            'worldabc'
            &gt;&gt;&gt; StringHelper.append_unique("foo", "bar")
            'foobar'
        """
        overlap = 0
        for i in range(1, min(len(s1), len(s2))+1):
            if s1[-i:] == s2[:i]:
                overlap = i
        return s1 + s2[overlap:]


class Clippy:
    def __init__(self, clippy_path: str):
        self.conn = False
        self.clippy_path = clippy_path
        self._min = None
        self.conn = sqlite3.connect(clippy_path)

    def __del__(self):
        if self and self.conn:
            self.conn.close()

    def all(self) -&gt; List[Dict]:
        cursor = self.conn.cursor()
        cursor.execute("""
SELECT rowid, item
FROM clipboard
WHERE dataType = 0
        """)
        rows = cursor.fetchall()
        columns = [column[0] for column in cursor.description]
        return [dict(zip(columns, row)) for row in rows]

    def _upsert_min(self, new_min: float) -&gt; float:
        now = datetime.now()
        if os.path.isfile(FILE_NAME):
            # Get previously set last updated at
            filetime = datetime.fromtimestamp(os.path.getmtime(FILE_NAME))

            # If less than 1 hour use that value
            if now - filetime &lt; timedelta(hours=1):
                # touch the file to renew the value timeout
                os.utime(FILE_NAME, (now.timestamp(), now.timestamp()))
                logging.debug(f'{TIMESTAMP}: touching `{FILE_NAME}`')

                # read the value
                with open(FILE_NAME, 'r') as f:
                    try:
                        return float(f.read())
                    except Exception as e:
                        pass

        logging.debug(f'{TIMESTAMP}: writing new min `{new_min}` to file `{FILE_NAME}`')
        with open(FILE_NAME, 'w') as f:
            f.write(str(new_min))
        return new_min

    def get_min(self) -&gt; int:
        if self._min is None:
            cursor = self.conn.cursor()
            cursor.execute("""
SELECT min(rowid)
FROM clipboard
WHERE dataType = 0
ORDER BY ts DESC, rowid DESC
LIMIT 1;
        """)
            result = cursor.fetchone()
            if result is not None:
                self._min = self._upsert_min(result[0])
        return self._min or 0

    def get_recent(self) -&gt; List[Dict]:
        cursor = self.conn.cursor()
        cursor.execute("""
SELECT rowid, item, apppath
FROM clipboard
WHERE dataType = 0
ORDER BY ts DESC, rowid DESC
LIMIT 35
        """)
        rows = cursor.fetchall()
        columns = [column[0] for column in cursor.description]
        return [dict(zip(columns, row)) for row in rows]


class Presenter:
    def __init__(self, clippy: Clippy, input_string: str = ""):
        self.clippy = clippy
        self.items = [] if input_string.endswith(";") else clippy.get_recent()
        self.input_string = input_string

    def __setattr__(self, name: str, value: Any) -&gt; None:
        if name == 'items':
            if not isinstance(value, list):
                raise ValueError('items must be a list')
            super().__setattr__(name, value)
        else:
            super().__setattr__(name, value)

    def add(self, item: Dict) -&gt; None:
        self.items.append(item)

    def decorated_items(self) -&gt; List[Dict]:
        decorated_list = []
        typed_var = re.search(r'[ft][0-9A-Fa-f]{2,}$', self.input_string)
        for item in self.items:
            [item1, item2] = self.decorate_item(item)
            if typed_var is None or item1['title'].startswith(typed_var.group(0)):
                decorated_list.append(item1)
            if typed_var is None or item2['title'].startswith(typed_var.group(0)):
                decorated_list.append(item2)
        return decorated_list

    def decorate_item(self, item: Dict) -&gt; List[Dict]:
        try:
            fvalue = float(re.sub(r'[^\d.]+', '', item['item']))
        except Exception as e:
            fvalue = 0.0
        lmin = self.clippy.get_min()
        rowid = hex(int(item['rowid']-lmin))[2:]
        return [
            {
                "title": f"f{rowid}",
                "subtitle": fvalue,
                "valid": False,
                "autocomplete": StringHelper.append_unique(self.input_string, f"f{rowid}"),
                "icon": {
                    "type": "fileicon",
                    "path": item['apppath'],
                }
            },
            {
                "title": f"t{rowid}",
                "subtitle": item['item'].replace("\n", "Â¶"),
                "valid": False,
                "autocomplete": StringHelper.append_unique(self.input_string, f"t{rowid}"),
                "icon": {
                    "type": "fileicon",
                    "path": item['apppath'],
                }
            },
        ]

    def to_a(self) -&gt; List[Dict]:
        return self.decorated_items()


class MagicEval:
    def __init__(self, clippy: Clippy):
        self.clippy = clippy

    def _eval(self, input_string: str) -&gt; Any:
        try:
            result = eval(input_string)
            logging.debug(f'{TIMESTAMP}: Input: {input_string}, Output: {result}')
            return result
        except Exception as e:
            logging.exception(f"{TIMESTAMP}: Error / Input: {input_string} =&gt; Exception: {str(e)}\n")
            raise e

    def evaluate(self, input_string: str) -&gt; List[Dict]:
        if len(input_string) == 0:
            return [
                {
                    "title": "ğŸ",
                    "subtitle": "ğŸŒ» Keep typing...",
                }
            ]
        try:
            # strip the ending ;
            if input_string[-1] == ";":
                input_string = input_string[:-1]
            # globals
            self.populate_global()
            # eval
            result = str(self._eval(input_string))
            # results
            return [
                {
                    "title": result.replace("\n", "Â¶"),
                    "arg": result,
                }
            ]
        except Exception as e:
            return [
                {
                    "uid": "cliprepl",
                    "title": "ğŸš§ " + input_string,
                    "subtitle": e.args[0],
                }
            ]

    def populate_global(self):
        # Defaults to de-clutter the logs
        globals()['f'] = 0.0
        globals()['t'] = ""

        # Create a cursor object
        items = self.clippy.all()
        lmin = self.clippy.get_min()
        for row in items:
            rowid = hex(int(row['rowid']-lmin))[2:]
            try:
                item = float(re.sub(r'[^\d.]+', '', row['item']))
                globals()['f' + rowid] = item
            except Exception as e:
                globals()['f' + rowid] = 0.0
            try:
                item = str(row['item'])
                globals()['t' + rowid] = item
            except Exception as e:
                globals()['t' + rowid] = ""

# Main
is_ci = str(os.environ.get("CI", "false")).lower() == 'true'
input_string = (os.environ.get("QUERY") or "{query}").strip()
if not is_ci and not input_string.startswith('.'):
    # Setup
    clippy = Clippy(os.path.abspath(os.environ.get('DB_PATH', '')))
    meval = MagicEval(clippy=clippy)
    presenter = Presenter(clippy, input_string)
    # Items
    type_ahead_items = presenter.to_a()
    eval_items = meval.evaluate(input_string)
    # Response
    print(json.dumps({
        "items": eval_items + type_ahead_items
    }))
</string>
				<key>scriptargtype</key>
				<integer>0</integer>
				<key>scriptfile</key>
				<string></string>
				<key>subtext</key>
				<string></string>
				<key>title</key>
				<string>ğŸ</string>
				<key>type</key>
				<integer>9</integer>
				<key>withspace</key>
				<false/>
			</dict>
			<key>type</key>
			<string>alfred.workflow.input.scriptfilter</string>
			<key>uid</key>
			<string>BB41D459-AE65-4994-A143-46C202E348C0</string>
			<key>version</key>
			<integer>3</integer>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>concurrently</key>
				<false/>
				<key>escaping</key>
				<integer>68</integer>
				<key>script</key>
				<string>"""
ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ

Edit me!

This is a place to put your custom functions and imports.

When we include this file, we rewrite stdout to stderror since stdout can interfere with Alfred results.

ğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸğŸ

"""


import numpy as np

print(np.array([1,2,3]))</string>
				<key>scriptargtype</key>
				<integer>1</integer>
				<key>scriptfile</key>
				<string></string>
				<key>type</key>
				<integer>9</integer>
			</dict>
			<key>type</key>
			<string>alfred.workflow.action.script</string>
			<key>uid</key>
			<string>13C80445-BF4B-49E0-8AE9-3EFB5AFDEDE2</string>
			<key>version</key>
			<integer>2</integer>
		</dict>
	</array>
	<key>readme</key>
	<string>![Icon](./icon.png)

## ğŸ clip.py

A REPL with Alfred's clipboard history being easily accessible in scripts.

Technically this is a `REP`, since the `L` in REPL is for loop. The output is put into your clipboard, so it's value is preserved, but only as another clipboard item. Any state you create in a previous evaluation is not remembered.

### ğŸ“¶ Setup

By default the `User Configuration` should be setup correctly if you are using Alfred 5.

	* `ğŸ’½ Database Path` - The PATH to the `clipboard.alfdb` file.
	* `ğŸ—ƒï¸ Log Level`  - The level of debugging you want. Defaults to `info`.

## âŒ¨ï¸ Usage

Try: `clippy&gt;1+1`

Open the prompt by typing `cliprepl&gt;` and you'll be presented with a list of previous clipboard items. Try using this as a standard Python REPL such as `cliprepl&gt;1+1` will give you `2`

### ğŸ“‹ Clipboard

Try: `clippy&gt;t1+t1`

Most of the results you are seeing are the clipboard contents.

To read the results you'll notice that
	* `title` is a unique identifier, which equates to a hex'd of rowid
		* By hex, I mean that a rowid of `231` would turn into `e7`
	* `subtitle` is the value of the item (try hitting `cmd` for the float)

To access the variables in your command, you'll need to give it a type prefix.

#### Prefixes

	* `t` prefix: (eg `te7`) would be the the value casted as a string.
		* For example `cliprepl&gt; te7+te7` would append the text to itself.
	* `f` prefix: (eg `fe7`) is the variable casted as a float.
		* For example `cliprepl&gt; fe7+fe7` would add the two floats together.

#### Advanced

	* Hitting `&lt;enter&gt;` or `&lt;tab&gt;` would autocomplete into ğŸ© Alfred.
	* Hitting `&lt;cmd&gt;` will show you the value casted as a float.
	* Ending your query with a semicolon (`;`) will hide the clipboard results.
	* Add custom functions and imports to the ğŸ§¡ Orange "Run Script"

## ğŸ”Œ Developers, Developers, Developers

### ğŸªµ Logs

Logs are routed to stderr, this makes them visible in the debugger.

### ğŸ“ Tests

There are a handful of unit tests that are runnable as well:

	* `clippy&gt;.test`

### ğŸ’½ Schema

For reference, here is the schema of the `clipboard.alfdb` file as it's currently known.

* `rowid` : A unique identifier generated by sqlite.
* `item` : Likely the value.
* `ts` : The timestamp, in seconds, when it was captured. Non unique.
* `app` : A short name for the application it was copied from.
* `apppath` : The absolute path of the application it was copied from.
* `dataType` : Enum of `0` meaning text, or `1` meaning an image.
* `dataHash` : If `dataType` is `1` this is a reference to the file on disk.

We do not simply sort by `rowid` but often by `ts` as well (`ts DESC, rowid DESC`) because it's possible for Alfred to update the `ts` in cases where you copy it back to your clipboard.</string>
	<key>uidata</key>
	<dict>
		<key>13C80445-BF4B-49E0-8AE9-3EFB5AFDEDE2</key>
		<dict>
			<key>colorindex</key>
			<integer>2</integer>
			<key>note</key>
			<string>ğŸŒˆ Custom Scripts</string>
			<key>xpos</key>
			<real>165</real>
			<key>ypos</key>
			<real>335</real>
		</dict>
		<key>14258FF9-2C70-4903-BC3E-C8FAA1CE1A7D</key>
		<dict>
			<key>colorindex</key>
			<integer>4</integer>
			<key>xpos</key>
			<real>540</real>
			<key>ypos</key>
			<real>210</real>
		</dict>
		<key>59A0180B-0FAD-4510-99A7-EF3D593B68EE</key>
		<dict>
			<key>colorindex</key>
			<integer>11</integer>
			<key>xpos</key>
			<real>540</real>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>B6FE8212-7A0A-4A71-A922-0FE50BD12268</key>
		<dict>
			<key>colorindex</key>
			<integer>6</integer>
			<key>note</key>
			<string>ğŸ“ For testing, should be removed in production.</string>
			<key>xpos</key>
			<real>45</real>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>BB41D459-AE65-4994-A143-46C202E348C0</key>
		<dict>
			<key>colorindex</key>
			<integer>5</integer>
			<key>xpos</key>
			<real>45</real>
			<key>ypos</key>
			<real>215</real>
		</dict>
		<key>D4F0197D-C1DD-4038-8B31-AF540F784683</key>
		<dict>
			<key>colorindex</key>
			<integer>6</integer>
			<key>xpos</key>
			<real>225</real>
			<key>ypos</key>
			<real>50</real>
		</dict>
		<key>EB6D5422-62A8-413C-917C-ABD99CBC6D62</key>
		<dict>
			<key>colorindex</key>
			<integer>10</integer>
			<key>xpos</key>
			<real>395</real>
			<key>ypos</key>
			<real>70</real>
		</dict>
	</dict>
	<key>userconfigurationconfig</key>
	<array>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>~/Library/Application Support/Alfred/Databases/clipboard.alfdb</string>
				<key>filtermode</key>
				<integer>2</integer>
				<key>placeholder</key>
				<string></string>
				<key>required</key>
				<true/>
			</dict>
			<key>description</key>
			<string>The path to the `clipboard.alfdb` file.</string>
			<key>label</key>
			<string>ğŸ’½ Database Path</string>
			<key>type</key>
			<string>filepicker</string>
			<key>variable</key>
			<string>DB_PATH</string>
		</dict>
		<dict>
			<key>config</key>
			<dict>
				<key>default</key>
				<string>INFO</string>
				<key>pairs</key>
				<array>
					<array>
						<string>DEBUG</string>
						<string>DEBUG</string>
					</array>
					<array>
						<string>INFO</string>
						<string>INFO</string>
					</array>
					<array>
						<string>WARNING</string>
						<string>WARNING</string>
					</array>
					<array>
						<string>ERROR</string>
						<string>ERROR</string>
					</array>
					<array>
						<string>CRITICAL</string>
						<string>CRITICAL</string>
					</array>
				</array>
			</dict>
			<key>description</key>
			<string>See ğŸ Python's Documentation
https://docs.python.org/3/library/logging.html#logging-levels</string>
			<key>label</key>
			<string>ğŸ—ƒï¸ Log Level</string>
			<key>type</key>
			<string>popupbutton</string>
			<key>variable</key>
			<string>LOG_LEVEL</string>
		</dict>
	</array>
	<key>variablesdontexport</key>
	<array/>
	<key>version</key>
	<string>0.0.1</string>
	<key>webaddress</key>
	<string>https://github.com/mxbaylee</string>
</dict>
</plist>
